## 记分牌算法仿真器

#### 实验目的

模拟记分牌算法，实现指令的动态调度，加深对指令相关性的理解。



#### 记分牌指令动态调度算法原理

- 记分牌是一个集中控制部件，其功能是控制数据寄存器与处理部件之间的数据传送。在记分牌中保存有与各个处理部件相联系的寄存器中的数据装载情况。当一个处理部件所要求的数据都已就绪，记分牌允许处理部件开始执行。当执行完成后，处理部件通知记分牌释放相关资源。所以在记分牌中记录了数据寄存器和多个处理部件状态的变化情况，通过它来检测和消除或减少数据相关性，加快程序的执行速度。目的是再无资源竞争的前提下保持每一个时钟周期执行一条指令的速率。

- 思想方法：尽可能提早指令的执行。当一条指令暂停执行时，如果其他后继指令与暂停指令及已发射的指令无任何相关，则仍然可以发射，执行。

- 步骤：
  - **发射**：如果指令的一个功能单元空闲（功能部件状态的`busy`字段），且没有其它活动指令以同一寄存器为目标寄存器（目标寄存器状态是否为空），则记分牌向功能单元发射指令，并更新指令状态。该步骤能解决**结构冒险**和**WRW冒险。**
  - **读取操作数**：如果不存在检查活动指令写入源寄存器（`Rj`和`Rk`字段为yes），记分牌将该指令发送到功能部件（`Rj`和`Rk`字段标记为no）。该步骤能解决**RAW冒险**。
  - **执行**：功能单元开始执行对应操作，更新功能单元状态。当结果就绪后，通知记分牌。
  - **写结果**：当其它活动指令不需要读取当前计算结果即将写入的寄存器，写回寄存器，并清空该条指令在记分牌记录的状态，同时修改以该指令目标寄存器作为源操作数的指令的`Rj`和`Rk`字段。该步骤能解决**WAR冒险**。



#### 测试用例

在instance目录中，包含含有各种冲突的测试用例，通过



#### 框架

- 实验内容：

本实验在Visual Studio 2022上使用C\++语言编写代码实现模拟记分牌算法。选择C++是因为该语言具有丰富的STL标准模板库，对于编写代码来说更加简便。选择Visual Studio是因为调试内存越界和内存泄漏非常方便，也可直接在其他类似devc++等软件运行，不需要再配置环境。

>   下面图展示了整个程序的执行流程。

![image-process](.\picture\image-process.png)



#### 技术路线

- 1.设计数据结构

经过考虑`Instruction`里面的参数过多，定义了一个结构体 `node`，用于存储每条指令的详细信息，包括操作码、功能部件状态、寄存器索引、是否就绪标志、功能部件请求和允许信号、周期计数和时间戳。

使用数组记录功能部件占用向量**，**功能部件占用向量等。

- 2.初始化和分配空间

处理输入，并对数组分配相应的空间

- 3.程序的循环（核心部分）

>   首先通过观察可以发现，记分牌调度算法每一个周期的执行都会判断此时正在执行的指令的下一条指令能否发射，并且记分牌调度算法还有一个原则就是每次只能发射一条指令，然后是所有正在执行的指令能否进行此条指令的下一个阶段，然后我们再针对每一条指令在执行到Issue、Read、Exec、Write阶段所需要面对的冲突检测，这样我们就可以把整个动态调度算法总结在一起。

>   所以创建一个循环，然后在每个循环中我们需要做到：在每个阶段去判断可能出现的所有条件。

1.  如果指令执行到了Issue阶段，我们需要根据指令的op判断此时如果功能部件不Busy，并且指令的目的寄存器 `fi` 没有被其他指令写入（`!result[instruction[x].fi]`），则检查是否存在写后写冲突。然后更新当前指令 `instruction[x]` 的状态，包括功能部件索引 `busy`，源操作数的状态 `qj` 和 `qk`，以及是否就绪的标志 `rj` 和 `rk`，记录完成当前阶段的周期 `time[0]`。如果源操作数已经写入，则直接设置 `rj` 和 `rk` 为 1；如果还在等待，则将当前指令索引 `x` 压入对应寄存器的等待队列 `wait`。同时更新目的寄存器状态，将当前指令索引 `x` 设置为指令的目的寄存器 `fi` 的写入指令，表示该寄存器已被当前指令占用。从而此阶段结束，因为算法每次只能发射一条指令。然后从指令的状态循环中跳出。然后去执行一条指令。
2.  如果指令执行到了Read阶段，对于每条指令，检查其源操作数是否已经就绪。这是通过检查指令结构中的 `rj` 和 `rk` 标志位来实现的。如果两个标志位都为真（非零），表示两个源操作数都已准备就绪。记录当前周期 `cycle` 到指令的周期时间`time[2]`, 表示读操作数阶段完成的时间。然后跳出。
3.  如果指令执行到了Exec阶段，主要是由于指令的执行周期可能不同，所以每次执行到了这个状态，将 `qj` ，`qk` ， `rj` 和 `rk` 重置为0，表示源操作数已被读取，不再需要等待（这个地方更新不能放在Read阶段，不然可能会出现读后写冲突！！！）。将指令的cycle的数值减1，然后每一次对clock的值进行判断，如果为0那么就是执行完毕，然后跳出。
4.  如果指令执行到了Write阶段，检查读后写冲突，如果没有则清除目标寄存器 `fi` 的写入状态，功能部件的占用状态并且更新等待该结果的指令状态，将 `wait[instruction[x].fi]` 队列中的指令的 `rj` 或 `rk` 设置为 1，表示它们可以继续执行。
5.  然后每次大循环执行完毕之后，将结果Display一下，然后cycle++。